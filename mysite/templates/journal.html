<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Learning Journal - Journal</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#0077cc">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" />
</head>
<body>
  <header><div id="nav-container"></div></header>

  <main class="content">
    <button id="theme-toggle" class="theme-btn">ðŸŒ™ Toggle Dark Mode</button>

    <section>
      <h2>Write a Server-Backed Journal Entry</h2>
      <p>These entries are stored permanently on the Flask backend in <code>reflections.json</code>.</p>
      <form id="server-entry-form">
        <textarea id="reflection-text" rows="5" placeholder="Write your entry for the Flask server..."></textarea><br>
        <button type="submit">ðŸ’¾ Save to Server</button>
      </form>

      <h3>Reflections from Flask Server</h3>
      <div id="json-reflections-container">
        <p>Loading reflections from Flask...</p>
      </div>

      <div class="python-info">
        <h3>How this works (Frontend --&gt; Backend):</h3>
        <ol>
          <li>You submit the form -> <code>backend.js</code> sends a <strong>POST</strong> request to <code>/api/reflections</code>.</li>
          <li>Flask handles the POST request, saves the data to <code>reflections.json</code>, and returns a 201 status.</li>
          <li>The page is updated by sending a <strong>GET</strong> request to <code>/api/reflections</code>.</li>
          <li>The <strong>Delete</strong> button uses a <strong>DELETE</strong> request to <code>/api/reflections/&lt;index&gt;</code> to remove entries.</li>
        </ol>
      </div>
    </section>

    <section>
      <h2>Write a Local Draft (Client-Only)</h2>
      <form id="entry-form">
        <textarea id="entry-text" rows="5" placeholder="Local draft saved using localStorage (only visible in this browser)..."></textarea><br>
        <button type="submit">ðŸ’¾ Save Local Draft</button>
      </form>

      <h3>Saved Local Entries</h3>
      <ul id="entry-list" style="list-style: none; padding-left: 0;"></ul>
    </section>

    <section>
      <h2>Weekly Journal</h2>

          <!-- MINI PROJECT -->
      <article>
        <button class="collapsible">Hide Entry</button>
        <div class="collapsible-content">
          <h3>Week 8 Entry: Mini Project Reflection</h3>

          <p><strong>1. What additional features did you add to your Learning Journal?</strong><br>
          For my Mini Project, I expanded the application's functionality by introducing a <strong>Creative Zone</strong> and a comprehensive <strong>Dashboard UI overhaul</strong>. The Creative Zone is built using the HTML5 <strong>Canvas API</strong>, which provides a 2D drawing context for freehand sketching. Unlike standard text entries, this allows for visual brainstorming. I implemented a JavaScript controller in <code>creative.js</code> to handle the drawing logic.
          <br><code>// creative.js: Initializing 2D Context<br>const ctx = canvas.getContext("2d");<br>ctx.lineWidth = 3;<br>ctx.lineCap = "round";</code><br>
          The feature includes a clear-canvas tool and a download function that converts the canvas into a PNG using <code>toDataURL()</code>. Additionally, I completely redesigned the Homepage (<code>index.html</code>) to function as an app dashboard. I moved away from simple text links to a <strong>CSS Grid system</strong> featuring large, tappable cards. 
          <br><code>/* style.css: Dashboard Grid */<br>.dashboard-grid {<br>  display: grid;<br>  grid-template-columns: 1fr 1fr;<br>  gap: 15px;<br>}</code><br>
          This redesign was supported by a dynamic JavaScript greeting system that detects the user's local time to display "Good Morning" or "Good Evening," significantly improving the personalized feel of the app.</p>

          <p><strong>2. Why did you choose your mini project idea?</strong><br>
          I chose to build the <strong>Creative Zone</strong> and the <strong>Dashboard UI</strong> because I wanted to challenge the perception of a "journal" as a purely static, text-heavy platform. In mobile development, user engagement is paramount, and adding a tactile, interactive element like a drawing pad makes the application feel like a professional tool rather than a standard webpage. I specifically wanted to master the <strong>HTML5 Canvas API</strong> because it is a fundamental technology for graphics and data visualization. By building a sketchpad from scratch, I gained a deeper understanding of how browsers handle raw pixel data and complex event listeners. 
          <br><code>// index.html: Hero Greeting Logic<br>const hour = new Date().getHours();<br>if (hour < 12) greetingEl.innerHTML = "Good Morning! â˜€ï¸";</code><br>
          The Dashboard redesign was chosen to fulfill the core philosophy of a <strong>Progressive Web App (PWA)</strong>. A PWA should not just work offline; it should mimic the visual hierarchy and ease of use found in native iOS or Android applications. By implementing a grid-based card layout, I prioritized the user experience for mobile users, ensuring that navigation is intuitive and accessible for thumb-based interaction on handheld devices, which is a key requirement for modern mobile-first development.</p>

          <p><strong>3. What technical challenges did you face and how did you solve them?</strong><br>
          The most significant challenge was handling the <strong>input disparity between Desktop and Mobile devices</strong>. My initial code relied on mouse events like <code>mousedown</code> and <code>mousemove</code>, which do not trigger on touchscreens. To solve this, I had to implement parallel <strong>Touch Event Listeners</strong> (<code>touchstart</code> and <code>touchmove</code>).
          <br><code>// creative.js: Mobile Touch Support<br>canvas.addEventListener("touchstart", (e) => {<br>  e.preventDefault(); // Prevents page scrolling<br>  const pos = getTouchPos(canvas, e);<br>  ctx.beginPath();<br>  ctx.moveTo(pos.x, pos.y);<br>});</code><br>
          A major hurdle was that dragging a finger on the canvas would scroll the entire browser page. I solved this by calling <code>e.preventDefault()</code> within the touch listeners and applying <code>touch-action: none</code> in the CSS. Another challenge was coordinate mapping; since touch coordinates are relative to the viewport, I wrote a custom helper function <code>getTouchPos</code> that uses <code>getBoundingClientRect()</code> to calculate the exact position relative to the canvas. This ensured that the "ink" appeared exactly where the user touched the screen, regardless of the zoom level or page scroll position.</p>

          <p><strong>4. What would you improve if given more time?</strong><br>
          If granted more time, my first priority would be to implement <strong>Server-Side Image Storage</strong>. Currently, drawings are only available for local download. I would upgrade the Flask backend to accept <code>Base64</code> strings from the canvas and store them in the serverâ€™s file system. 
          <br><code># flask_app.py: Conceptual Route for Image Saving<br>@app.route("/api/save-sketch", methods=["POST"])<br>def save_sketch():<br>    image_data = request.json['image'] # Base64 string<br>    # Logic to decode and save as .png...</code><br>
          Secondly, I would migrate the data persistence layer from the current JSON file to a robust <strong>SQLite Database</strong> using SQLAlchemy. While <code>reflections.json</code> is great for a prototype, a relational database would prevent data corruption during simultaneous user requests and allow for advanced features like searching through entries or tagging sketches by category. Finally, I would enhance the <strong>Creative Zone</strong> by adding a full tool suite, including a color picker, variable brush sizes, and an "Undo" feature using a stack to store previous canvas states. These improvements would transition the application from a student project into a fully-featured productivity tool suitable for professional use.</p>

          <button class="copy-entry">ðŸ“‹ Copy Entry</button>
        </div>
      </article>
      

            <article>
        <button class="collapsible">Hide Entry</button>
        <div class="collapsible-content">
          <h3>Week 7 Entry: PWA & Offline Capabilities</h3>

          <p><strong>1. Why is it useful to enhance your Flask app with PWA features?</strong><br>
          Enhancing a Flask app with PWA features transforms it from a simple website into a <strong>reliable, native-like application</strong>. By adding a Web Manifest, users can install the journal to their home screen, making it accessible with a single tap. By adding a Service Worker, the app becomes resilient to network failures, allowing users to read their past entries even when they have no internet connection. This improves the overall user experience and performance.</p>

          <p><strong>2. What did you use to support offline access and dynamic data?</strong><br>
          To support offline access, I implemented a <strong>Service Worker (`sw.js`)</strong>. I configured it to cache essential shell files (HTML, CSS, JS) and the `manifest.json` during the `install` phase. For dynamic data, I updated the <strong>Flask backend (`flask_app.py`)</strong> to serve the Service Worker file from the root URL (`/sw.js`) instead of the static folder. I also used the <strong>Fetch API</strong> in the Service Worker to intercept network requests: if the network fails, it serves the cached versions of my pages instead of showing an error.</p>

          <p><strong>3. What extra feature did you add, and why?</strong><br>
          I added a <strong>Real-Time Offline Notification System</strong>. Since my app relies on a server database (`reflections.json`) to save new entries, users need to know if they are offline before they try to submit a form. I used JavaScript's `window.addEventListener` for 'offline' and 'online' events to detect connectivity changes instantly. When the internet disconnects, a banner appears warning the user they are in "Offline Mode". This improves usability by preventing user frustration.</p>

          <p><strong>4. Did you face any challenges deploying your PWA, and how did you solve them?</strong><br>
          Yes, I faced two main challenges. First, my Service Worker initially couldn't cache the main HTML pages because it was located in `/static/js/`, restricting its scope. I solved this by creating a specific route in Flask (`@app.route('/sw.js')`) to serve the file from the root URL. Second, the "Install App" button wouldn't appear because the browser couldn't find my icons due to a relative path error. Updating the paths in `manifest.json` to absolute paths (`/static/images/...`) fixed the issue.</p>

          <button class="copy-entry">ðŸ“‹ Copy Entry</button>
        </div>
      </article>


            <article>
        <button class="collapsible">Hide Entry</button>
        <div class="collapsible-content">
          <h3>Week 6 Entry: Frontend & Backend Integration (Flask)</h3>

          <p><strong>1. Why is the frontend-backend connection important?</strong><br>
          The frontend-backend connection is crucial because it allows the Progressive Web App (PWA) to move beyond being a static interface and become a fully functional application capable of processing and storing user data. The frontend handles the visual display and user interaction, while the backend (Flask) handles the persistence of data, security, and business logic, which are essential for any scalable application.</p>

          <p><strong>2. Which HTTP methods did you use in Flask, and why?</strong><br>
          I used three primary HTTP methods:
          <ul>
            <li><strong>GET</strong>: Used for the <code>/api/reflections</code> route to retrieve reflections from the `reflections.json` file and send them to the frontend for display.</li>
            <li><strong>POST</strong>: Used for the <code>/api/reflections</code> route when submitting a new reflection from the form. This method creates a new entry and saves it to the JSON file.</li>
            <li><strong>DELETE</strong>: Used for the extra feature route <code>/api/reflections/&lt;index&gt;</code> to remove a specific reflection from the JSON file based on its index. This method ensures data can be managed server-side.</li>
          </ul>
          </p>

          <p><strong>3. What is the difference between using Flask to store and load JSON data and reading JSON directly in the browser?</strong><br>
          When reading JSON directly in the browser, the data is static (like an asset file). Any changes made by the user are only saved locally (via `localStorage`) or lost upon refresh, and the central JSON file cannot be updated. Using Flask (backend) is fundamentally different: Flask executes the Python script, allowing it to write back and permanently update the `reflections.json` file on the server's file system, ensuring persistence and shared data across different users and devices.</p>

          <p><strong>4. Did you face any difficulties when running your project on PythonAnywhere? How did you handle them?</strong><br>
          The main difficulty was handling the file paths for saving `reflections.json`. Initially, Flask tried to save the file next to `flask_app.py`. To fix this, I updated the path in my Python script to `static/backend/reflections.json` and ensured the `static/backend/` folders existed on PythonAnywhere. I also had to remember to Reload the web app every time I updated the Python code to ensure the server used the new paths and routes.</p>

          <p><strong>5. What extra feature did you build into your PWA with Flask, and why did you add it?</strong><br>
          I built a Delete Reflection feature using the DELETE HTTP method. I added this feature because it gives the user full CRUD (Create, Read, Update, Delete) control over their data, which is essential for a complete journal application. It demonstrates proficiency in handling server requests beyond simple data retrieval and submission.</p>

          <button class="copy-entry">ðŸ“‹ Copy Entry</button>
        </div>
      </article>


      <article>
        <button class="collapsible">Hide Entry</button>
        <div class="collapsible-content">
          <h3>Week 5 Entry</h3>
          <h3>What is the difference between storing data in a JSON file versus browser storage?</h3>
          <p>
            JSON files are stored on the server/file system and persist across different browsers and devices when deployed. Browser storage (like localStorage) is local to the user's specific browser and doesn't transfer between devices. JSON files are better for data that needs to be shared or backed up, while browser storage is ideal for user-specific preferences and temporary data.
          </p>

          <p><strong>How did you use Python to create or update your JSON file?</strong><br>
          I created a Python script that uses the <code>json</code> module to read and write JSON files. The script takes user input through the command line, creates a reflection object with date and content, appends it to the existing JSON array, and saves it back to the file with proper formatting.</p>

          <p><strong>What does your PWA show locally, and what will users see on GitHub? Are they the same? Why or why not?</strong><br>
          Locally, the PWA shows actual reflections from the JSON file that I can update using Python. On GitHub Pages, users will only see the initial JSON file content because GitHub serves static files - the Python script doesn't run on their servers. They're different because GitHub Pages doesn't execute backend code.</p>

          <p><strong>What extra feature did you add to your PWA using the JSON file, and why?</strong><br>
          I added an export button that allows users to download their reflections as a JSON file. This provides data portability - users can backup their reflections, share them with others, or use the data in different applications. It enhances the user experience by giving them control over their data.</p>
          <button class="copy-entry">ðŸ“‹ Copy Entry</button>
        </div>
      </article>

      <article>
        <button class="collapsible">Hide Entry</button>
        <div class="collapsible-content">
          <h3>Week 4 Entry</h3>
          <h3>What Storage, Browser, and third party APIs did you choose, and why?</h3>
          <p id="week4-text">
            I used <code>localStorage</code> to save theme preference and journal entry drafts. For the Browser API, I added a Clipboard API button to copy journal entries. For the Third-Party API, I embedded a YouTube video using the YouTube iframe embed method to showcase a tutorial I found helpful.
          </p>
          <p><strong>How did you integrate each API with DOM manipulation?</strong><br>
          I used <code>localStorage.getItem()</code> and <code>setItem()</code> to persist theme and entry data. The Clipboard API was triggered by a button click using <code>navigator.clipboard.writeText()</code>. The YouTube video was inserted dynamically using <code>innerHTML</code> on a container element.</p>

          <p><strong>What challenges did you encounter, and how did you solve them?</strong><br>
          The biggest challenge was making sure the theme preference persisted across reloads and pages. I solved it by checking localStorage on page load and updating the toggle button label accordingly. I also had to handle clipboard permissions gracefully.</p>

          <p><strong>In what ways do these APIs improve your Learning Journal PWA?</strong><br>
          These APIs make the journal more interactive and user-friendly. Users can copy entries, enjoy consistent theme settings, and view external content like videos â€” all without leaving the app.</p>
          <button class="copy-entry">ðŸ“‹ Copy Entry</button>
        </div>
      </article>

      <article>
        <button class="collapsible">Hide Entry</button>
        <div class="collapsible-content">
          <h3>Week 3 Entry</h3>
          <p><strong>Which DOM selection methods did you use, and why?</strong><br>
          I used <code>getElementById</code> to target specific elements like the theme toggle and live date, and <code>querySelectorAll</code> to select multiple collapsible buttons and nav links. These methods gave me precise control over the page structure and allowed me to apply interactivity efficiently.</p>

          <p><strong>What was the most challenging part about linking JavaScript with your HTML?</strong><br>
          The trickiest part was replacing the static navigation with a reusable one injected via JavaScript. I had to make sure the active link was highlighted correctly and that the layout didn't break across pages. Debugbing the collapsible sections also took time, especially making sure the toggle button updated its label dynamically.</p>

          <p><strong>How did you test and debug your JavaScript code?</strong><br>
          I used <code>console.log()</code> to trace DOM selections and event triggers. I also refreshed each page after changes to confirm the nav injection, dark mode toggle, and collapsible sections worked consistently. Chrome DevTools helped me inspect elements and tweak styles live. Once everything behaved as expected, I committed the updates to GitHub for version control.</p>

          <p><strong>What did you learn?</strong><br>
          I learned how powerful the DOM is for building reusable and interactive components. Injecting navigation, toggling themes, and collapsing content all helped me understand how JavaScript can control both structure and style dynamically. It made my Learning Journal feel like a real app!</p>
        </div>
      </article>

      <article>
        <button class="collapsible">Hide Entry</button>
        <div class="collapsible-content">
          <h3>Week 2 Entry</h3>
          <p><strong>How did you approach mobile-first design?</strong><br>
          I started by designing for small screens first, using flexible layouts and percentages instead of fixed widths.
          Then I added media queries to adjust the spacing and layout for larger devices.</p>

          <p><strong>Most useful HTML/CSS concept?</strong><br>
          Using Flexbox helped me organize my navigation and page structure easily while keeping it responsive.</p>

          <p><strong>Most challenging part?</strong><br>
          The hardest part was fixing layout issues on mobile view, especially when content or padding caused the page to scroll sideways.
          I learned how to use <code>overflow-x: hidden</code> and flexible widths to make everything fit properly.</p>
        </div>
      </article>

      <article>
        <button class="collapsible">Hide Entry</button>
        <div class="collapsible-content">
          <h3>Week 1 Entry</h3>
          <h3>Reflection</h3>
          <p>This was my first time building mobile apps, and I learned a lot!</p>
          <p>I made the same Temperature Converter app two different ways:</p>
          <ul>
            <li><strong>As a Website (PWA):</strong> Works in any browser and can be installed like an app.</li>
            <li><strong>As a Native Android App:</strong> A real app installed from Android Studio.</li>
          </ul>
          <p><strong>What I Learned:</strong></p>
          <ul>
            <li>GitHub is like a "save button" for code</li>
            <li>VS Code is where I write my website code</li>
            <li>Android Studio is for making Android apps (but it's slow!)</li>
            <li>PythonAnywhere puts my website online for everyone to see</li>
          </ul>
          <p><strong>The Big Challenge:</strong><br>
          Each tool had its own problems. The website didn't want to install, Android Studio kept crashing, and putting the website online was confusing. But I fixed each problem one by one.</p>
          <p>Now I understand the difference between making a website that acts like an app versus making a real Android app. It was hard work, but I got everything working in the end!</p>
        </div>
      </article>
    </section>

    <section>
      <h2>Helpful Tutorial</h2>
      <div id="youtube-video"></div>
    </section>
  </main>

  <footer><p>Â© 2025 My Learning Journal</p></footer>

  <script src="{{ url_for('static', filename='js/script.js') }}"></script>
  <script src="{{ url_for('static', filename='js/storage.js') }}"></script>
  <script src="{{ url_for('static', filename='js/browser.js') }}"></script>
  <script src="{{ url_for('static', filename='js/thirdparty.js') }}"></script>
  <script src="{{ url_for('static', filename='js/backend.js') }}"></script>
</body>
</html>

